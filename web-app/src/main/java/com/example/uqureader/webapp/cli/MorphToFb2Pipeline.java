package com.example.uqureader.webapp.cli;

import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Command line utility that chains together the existing morphology tools so that a
 * {@code *.morph.tsv} file can be converted into an FB2 document in a single invocation.
 *
 * <p>The program sequentially runs {@link NaiveMorphologyPostProcessor},
 * {@link Morph2TranslationAugmenter} and {@link Morph3Fb2Exporter}. Intermediate
 * {@code *.morph2.tsv} and {@code *.morph3.tsv} files are generated by the individual
 * steps as usual. The resulting FB2 document is produced by the exporter.</p>
 */
public final class MorphToFb2Pipeline {

    private final NaiveMorphologyPostProcessor naivePostProcessor;
    private final Morph2TranslationAugmenter translationAugmenter;
    private final Morph3Fb2Exporter fb2Exporter;
    private final PrintStream out;
    private final PrintStream err;

    public MorphToFb2Pipeline(PrintStream out, PrintStream err) {
        this.out = Objects.requireNonNull(out, "out");
        this.err = Objects.requireNonNull(err, "err");
        NaiveTatarSuffixAnalyzer analyzer =
                NaiveTatarSuffixAnalyzer.fromClasspathOrDefault("/suffixes_tat.json", 4);
        this.naivePostProcessor = new NaiveMorphologyPostProcessor(analyzer, out, err);
        this.translationAugmenter = new Morph2TranslationAugmenter(out, err);
        this.fb2Exporter = new Morph3Fb2Exporter(out, err);
    }

    public static void main(String[] args) {
        MorphToFb2Pipeline pipeline = new MorphToFb2Pipeline(System.out, System.err);
        int exitCode = pipeline.run(args);
        if (exitCode != 0) {
            System.exit(exitCode);
        }
    }

    int run(String[] args) {
        if (args == null || args.length == 0) {
            printUsage();
            return 1;
        }

        List<Path> morphFiles = new ArrayList<>();
        Path dictionaryOverride = null;
        Path originalDir = null;
        Path explicitOriginal = null;

        for (int i = 0; i < args.length; i++) {
            String arg = args[i];
            switch (arg) {
                case "--dictionary":
                case "-d":
                    if (i + 1 >= args.length) {
                        err.println("Опция --dictionary требует путь к файлу словаря.");
                        return 1;
                    }
                    dictionaryOverride = Path.of(args[++i]);
                    if (!Files.exists(dictionaryOverride) || !Files.isRegularFile(dictionaryOverride)) {
                        err.printf("Файл словаря не найден: %s%n", dictionaryOverride);
                        return 2;
                    }
                    break;
                case "--original-dir":
                case "-o":
                    if (i + 1 >= args.length) {
                        err.println("Опция --original-dir требует путь к каталогу оригинальных текстов.");
                        return 1;
                    }
                    originalDir = Path.of(args[++i]);
                    if (!Files.exists(originalDir) || !Files.isDirectory(originalDir)) {
                        err.printf("Каталог оригинальных текстов не найден: %s%n", originalDir);
                        return 2;
                    }
                    break;
                case "--original":
                    if (i + 1 >= args.length) {
                        err.println("Опция --original требует путь к файлу оригинального текста.");
                        return 1;
                    }
                    explicitOriginal = Path.of(args[++i]);
                    if (!Files.exists(explicitOriginal) || !Files.isRegularFile(explicitOriginal)) {
                        err.printf("Оригинальный текст не найден: %s%n", explicitOriginal);
                        return 2;
                    }
                    break;
                default:
                    Path path = Path.of(arg);
                    if (!Files.exists(path)) {
                        err.printf("Файл не найден: %s%n", path);
                        return 2;
                    }
                    if (!Files.isRegularFile(path)) {
                        err.printf("Не является файлом: %s%n", path);
                        return 2;
                    }
                    morphFiles.add(path);
                    break;
            }
        }

        if (morphFiles.isEmpty()) {
            err.println("Не указаны входные *.morph.tsv файлы.");
            printUsage();
            return 1;
        }

        if (explicitOriginal != null && morphFiles.size() != 1) {
            err.println("Опция --original может использоваться только с одним входным файлом.");
            return 1;
        }

        for (Path morph : morphFiles) {
            out.printf("== Обработка %s ==%n", morph);

            int stage1 = naivePostProcessor.run(new String[]{morph.toString()});
            if (stage1 != 0) {
                err.printf("Этап наивного постпроцессинга завершился с кодом %d.%n", stage1);
                return stage1;
            }

            Path morph2 = toMorph2Path(morph);

            List<String> augmenterArgs = new ArrayList<>();
            if (dictionaryOverride != null) {
                augmenterArgs.add("--dictionary");
                augmenterArgs.add(dictionaryOverride.toString());
            }
            augmenterArgs.add(morph2.toString());
            int stage2 = translationAugmenter.run(augmenterArgs.toArray(new String[0]));
            if (stage2 != 0) {
                err.printf("Этап дополнения переводами завершился с кодом %d.%n", stage2);
                return stage2;
            }

            Path morph3 = toMorph3Path(morph2);

            List<String> exporterArgs = new ArrayList<>();
            if (originalDir != null) {
                exporterArgs.add("--original-dir");
                exporterArgs.add(originalDir.toString());
            }
            exporterArgs.add(morph3.toString());
            if (explicitOriginal != null) {
                exporterArgs.add(explicitOriginal.toString());
            }
            int stage3 = fb2Exporter.run(exporterArgs.toArray(new String[0]));
            if (stage3 != 0) {
                err.printf("Этап экспорта в FB2 завершился с кодом %d.%n", stage3);
                return stage3;
            }
        }

        return 0;
    }

    private void printUsage() {
        err.println("Использование: java -cp web-app-<версия>.jar "
                + "com.example.uqureader.webapp.cli.MorphToFb2Pipeline [опции] <файл.morph.tsv> [<файл.morph.tsv> ...]");
        err.println("Опции:");
        err.println("  --dictionary, -d <путь>     Использовать альтернативную SQLite-базу словаря.");
        err.println("  --original-dir, -o <путь>   Каталог, где искать оригинальные тексты.");
        err.println("  --original <путь>          Явно указать файл оригинального текста (для одного входа).");
        err.println("Инструмент последовательно запускает наивный постпроцессор, "
                + "дополняет файл переводами и экспортирует FB2.");
    }

    private Path toMorph2Path(Path input) {
        String candidate = fileName(input);
        if (candidate.endsWith(".morph.tsv")) {
            return input.resolveSibling(candidate.substring(0, candidate.length() - ".morph.tsv".length())
                    + ".morph2.tsv");
        }
        return input.resolveSibling(candidate + ".morph2.tsv");
    }

    private Path toMorph3Path(Path morph2) {
        String fileName = fileName(morph2);
        int idx = fileName.lastIndexOf(".morph2");
        if (idx >= 0) {
            int end = idx + ".morph2".length();
            String suffix = fileName.substring(end);
            String base = fileName.substring(0, idx);
            return morph2.resolveSibling(base + ".morph3" + suffix);
        }
        return morph2.resolveSibling(fileName + ".morph3");
    }

    private String fileName(Path path) {
        Path name = path.getFileName();
        if (name != null) {
            return name.toString();
        }
        String normalised = path.toString();
        int separator = normalised.lastIndexOf('/');
        if (separator >= 0 && separator + 1 < normalised.length()) {
            return normalised.substring(separator + 1);
        }
        return normalised;
    }
}

