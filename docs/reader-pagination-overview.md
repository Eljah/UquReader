# Reader pagination lifecycle

## First-time pagination
1. When the reader loads a document from assets, the background task returns a `LoadResult` with the plain text and token spans. The UI thread applies it via `applyLoadResult`, which resets pagination state, marks it dirty, and asks to display the initial character window. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L383-L406】
2. Showing that window eventually calls `ensurePagination`. With no cached layout yet, the method captures the current `PaginationSpec` (content width/height, text metrics, and document signature) and runs `recomputePagination` to split the document into page ranges sized for the viewport. It clears and rebuilds `pages`, adjusting each break to token boundaries, then persists the fresh snapshot. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L582-L618】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L685-L878】
3. `persistPagination` serializes those page breaks into a `PaginationDao.Snapshot` tied to the language pair and work id, and enqueues it for storage in the `visual_pagination` table. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L758-L778】【F:android-app/src/main/java/com/example/ttreader/data/PaginationDao.java†L27-L77】

## Subsequent openings
1. The next time the same work is opened with the same layout parameters, `ensurePagination` first attempts to hydrate the `pages` list from the cached snapshot. `applyCachedPagination` only accepts the cache when the stored dimensions, text metrics, and document signature exactly match the current `PaginationSpec`. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L598-L606】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L685-L719】
2. When the snapshot matches, the previously persisted page breaks are copied into memory and reused immediately, so the document appears without recomputing the layout. If the cache is missing, malformed, or mismatched (for example after a font or viewport change), the DAO entry is discarded and the pagination path falls back to the first-time recomputation flow. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L720-L756】【F:android-app/src/main/java/com/example/ttreader/data/PaginationDao.java†L79-L104】
3. During normal navigation (next/previous page) the reader simply moves a window across the already populated `pages` list. Because `paginationDirty` stays `false` and `paginationLocked` remains `true`, the expensive recomputation path is skipped until a layout-affecting change forces `markPaginationDirty` to clear the cache. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L598-L616】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L620-L659】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L929-L965】

## When `paginationLocked` flips
* The flag starts out `false` whenever the reader is cleared or a fresh document is applied. `clearContent` resets it as part of wiping the previous pagination, and `applyLoadResult` immediately queues `markPaginationDirty` so that the next navigation recomputes against the new viewport. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L306-L333】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L418-L444】
* While the layout dimensions are unstable we keep the flag down. Resizing the viewport (for example, after a rotation or keyboard appearance) triggers `markPaginationDirty`, which clears the cached page list and flips `paginationLocked` back to `false` until a compatible `PaginationSpec` is captured again. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L224-L237】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L620-L659】
* As soon as `ensurePagination` either rehydrates the cache or finishes recomputing, it commits the new `PaginationSpec`, marks the layout clean, and sets `paginationLocked = true`. All subsequent forward/backward navigation reuses that in-memory list until another dirtying event occurs. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L598-L616】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L526-L555】

## Why rapid flips can still flicker
Fast swipes enqueue multiple navigation targets, and each processed target ends up calling `renderPage`, which swaps the `TextView` content synchronously on the UI thread. Because the new page text is rendered through `TokenSpan` replacement spans, every update rebuilds the layout and asks each span to draw its run manually. The redraw therefore lands in several frames: the right edge of the card invalidates first, then the rest of the line cache catches up, so the left side may momentarily show glyphs from the previous page when pages are advancing faster than Android can finish its measure/layout/draw cycle. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L460-L558】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L967-L1066】【F:android-app/src/main/java/com/example/ttreader/reader/TokenSpan.java†L11-L69】

The effect disappears once the UI thread finishes the last pending `setText` pass. We currently rely on the platform's invalidation behaviour, so eliminating the flicker entirely would require double buffering (rendering into an off-screen `StaticLayout`) or pausing navigation while a previous draw is still pending.

## Why punctuation no longer wraps alone
The pagination step still refuses to split inside a token span: `adjustPageEndToTokenBoundary` walks the sorted `tokenSpans` list and snaps every page break back to the last span end that fits in the viewport. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L899-L927】 Previously, punctuation marks emitted as standalone tokens were not part of that list, so a break landing between a word token and the following comma or dash was snapped to the word boundary, leaving the punctuation at the start of the next page. The helper now treats runs of trailing punctuation as part of the preceding token when they immediately follow it without whitespace, extending the break to include them inside the current page. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L994-L1038】 This keeps commas, quotes, dashes, and similar marks attached to the word they follow while still avoiding splits inside lexical tokens.

## Handling spaced dash continuations

When a clause begins with a spaced dash (e.g. "... әзермен - ..." in the bundled `qabiz_qubiz.fb2`), the loader still emits three tokens: the lexical token before the dash, a standalone punctuation token for "-", and the following lexical token whose `prefix` already includes the leading space. The FB2 exporter does not attach morphology to the dash, so the resulting `Token` keeps `morphology = null`. 【F:android-app/src/main/java/com/example/ttreader/util/MorphDocumentParser.java†L25-L34】【F:android-app/src/main/java/com/example/ttreader/util/Fb2MorphParser.java†L19-L209】【F:android-app/src/main/assets/qabiz_qubiz.fb2†L52】

`buildContent` now synthesizes `TokenSpan`s for every character that reaches the reader—both for prefixes that arrive outside morphological tokens and for tokens whose morphology is missing—so the dash token ends up in `tokenSpans` alongside the surrounding whitespace. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L1552-L1637】【F:android-app/src/main/java/com/example/ttreader/model/Token.java†L6-L15】 Because the paginator sees a contiguous span list, `adjustPageEndToTokenBoundary` can snap directly to the dash instead of leaving a half-empty page before it, and the same spans are also available to the audio pipeline. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L899-L927】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L1552-L1637】
