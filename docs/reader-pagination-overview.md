# Reader pagination lifecycle

## First-time pagination
1. When the reader loads a document from assets, the background task returns a `LoadResult` with the plain text and token spans. The UI thread applies it via `applyLoadResult`, which resets pagination state, marks it dirty, and asks to display the initial character window. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L383-L406】
2. Showing that window eventually calls `ensurePagination`. With no cached layout yet, the method captures the current `PaginationSpec` (content width/height, text metrics, and document signature) and runs `recomputePagination` to split the document into page ranges sized for the viewport. It clears and rebuilds `pages`, adjusting each break to token boundaries, then persists the fresh snapshot. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L582-L618】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L685-L878】
3. `persistPagination` serializes those page breaks into a `PaginationDao.Snapshot` tied to the language pair and work id, and enqueues it for storage in the `visual_pagination` table. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L758-L778】【F:android-app/src/main/java/com/example/ttreader/data/PaginationDao.java†L27-L77】

## Subsequent openings
1. The next time the same work is opened with the same layout parameters, `ensurePagination` first attempts to hydrate the `pages` list from the cached snapshot. `applyCachedPagination` only accepts the cache when the stored dimensions, text metrics, and document signature exactly match the current `PaginationSpec`. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L598-L606】【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L685-L719】
2. When the snapshot matches, the previously persisted page breaks are copied into memory and reused immediately, so the document appears without recomputing the layout. If the cache is missing, malformed, or mismatched (for example after a font or viewport change), the DAO entry is discarded and the pagination path falls back to the first-time recomputation flow. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L720-L756】【F:android-app/src/main/java/com/example/ttreader/data/PaginationDao.java†L79-L104】

## Why punctuation can wrap alone
The pagination step never splits within a token span. `adjustPageEndToTokenBoundary` walks the sorted `tokenSpans` list and snaps every page break back to the last span end that fits in the viewport. 【F:android-app/src/main/java/com/example/ttreader/reader/ReaderView.java†L899-L927】 In the Tatar corpora we load, punctuation marks are emitted as individual tokens rather than being merged with the preceding word. When a page break lands between a word token and the following punctuation token, the snapping logic keeps the break before the punctuation so the word is not fragmented. Because the fallback whitespace scan only runs when no token boundary was found, the comma or dash is left as the first character on the next page. This keeps lexical tokens intact but can occasionally place punctuation on a separate page when the viewport height is tight.
